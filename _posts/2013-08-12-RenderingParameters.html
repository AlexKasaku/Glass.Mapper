---
layout: BlogLayout
title: Mapping Sitecore Rendering Parameters
image: http://marketplace.sitecore.net/~/media/Marketplace/Modules/S/Sitemap/Images/Sitemap2.ashx
abstract: A look at how we were able to map rendering parameters using Glass.Mapper.
caption: 08 Aug 2013
---
			
<p class="lead">
    In the next release of Glass.Mapper.Sc we will support mapping rendering parameters to object, in this post I will explain how
    we implemented this.
</p>
<p>
    You can get a pre-release version of this from the Glass.Mapper builder server right now (see the download page to find out how).
</p>
<p>
    I had recently been going through some of the Glass.Mapper.Sc unit tests and updating them to use a fake Item rather than an
    item pulled from the Sitecore database. To do this I created a method which I could pass a dictionary of Ids and values to the item 
    which contained the field values:
</p>
<pre class="csharp">
        public static Item CreateFakeItem(Dictionary&lt;Guid, string&gt; fields, string name="itemName")
        {
            var id = new ID(Guid.NewGuid());
            var templateId = new ID(Guid.NewGuid());
            var language = Language.Current;
            var version = Sitecore.Data.Version.Latest;
            
            var itemDefinition = new ItemDefinition(id, name, id, ID.Null);
            var fieldList = new FieldList();

            foreach (var fieldId in fields.Keys)
            {
                fieldList.Add(new ID(fieldId), fields[fieldId]);
            }

            var itemData = new ItemData(itemDefinition, language, version, fieldList);
            var item = new Item(id, itemData, new Database("master"));
            return item;
        }
</pre>
<p>
    The problem with this method was that fields had to be reference by ID, they couldn't be referenced by the field name. This got me 
    thinking about a possible solution and I wondered if the only requirement to get fields to work by name would be to specify a proper
    template ID. So I update the CreateFakeItem method to accept a template ID and a database:
</p>
<pre class="csharp">
        public static Item CreateFakeItem(Dictionary&lt;Guid, string&gt; fields, ID templateId, Database database, string name = "ItemName")
        {
            var id = new ID(Guid.NewGuid());
            var language = Language.Current;
            var version = Sitecore.Data.Version.Latest;

            var itemDefinition = new ItemDefinition(id, name, templateId, ID.Null);
            var fieldList = new FieldList();

            if (fields != null)
            {
                foreach (var fieldId in fields.Keys)
                {
                    fieldList.Add(new ID(fieldId), fields[fieldId]);
                }
            }

            var itemData = new ItemData(itemDefinition, language, version, fieldList);
            var item = new Item(id, itemData, database);
            return item;
        }
</pre>
<p>
    I then created a GetRenderingParameters method that would read the values in the rendering parameters string into the appropriate fields:
</p>

<pre class="csharp">
        public T GetRenderingParameters&lt;T&gt;(NameValueCollection parameters, ID renderParametersTemplateId) where T:class{

            var item = Utilities.CreateFakeItem(null, renderParametersTemplateId, SitecoreContext.Database, "renderingParameters");

            using (new SecurityDisabler() )
            {
                using (new VersionCountDisabler())
                {
                    item.Editing.BeginEdit();

                    foreach (var key in parameters.AllKeys)
                    {
                        item[key] = parameters[key];
                    }
                    T obj = item.GlassCast&ltT&gt;();

                    item.Editing.CancelEdit();
                    return obj;
                }
            }

        }
</pre>
<p>
    Now that I had an item that contained my rendering parameters as field values I could send it through the normal Glass.Mapper mapping 
    process using the GlassCast method. Finally I just needed to cancel the item editing to ensure no values are saved back to the database.
</p>
<p>
    Using the method we now have a very quick way to make fake versions of items which are useful for unit testing, this is one of the 
    tests for Glass.Mapper.Sc:
</p>
<pre class="csharp">
            //Assign
            string fieldValue = "3.141592";
            decimal expected = 3.141592M;
            var fieldId = Guid.NewGuid();

            var item = Helpers.CreateFakeItem(fieldId, fieldValue);
            var field = item.Fields[new ID(fieldId)];

            var mapper = new SitecoreFieldDecimalMapper();


            //Act
            var result = (decimal)mapper.GetField(field, null, null);

            //Assert
            Assert.AreEqual(expected, result);
</pre>
<p>
    If you look at the tutorial you will also  see under "Other" that you can actually pass any query string formatted string to 
    Glass.Mapper and have it mapped to a class as long as you have a matching template in Sitecore.
</p>
<p>
    For more information on how to access rendering parameters using Glass.Mapper see <li><a href="/docs/tutorial/sitecore/tutorial23/tutorial23.html">Tutorial 23</a> - Rendering Parameters</li>.
</p>
{% include share.html %}
<p class="muted">
    Mike - <a href="https://twitter.com/mikeedwards83">@mikeedwards83</a> 
</p>
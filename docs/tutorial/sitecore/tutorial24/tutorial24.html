---
layout: DocsLayout
title: Tutorial 24 - TDS Code Generation
---

{% include pageheader.html %}

<p>
    In this tutorial we will look at how you can used TDS to automatically generate classes that work with Glass.Mapper based on the 
    templates you have stored in TDS.
</p>
<p>
    For this demo I have a very simple project setup that includes my main website project and my TDS project:
</p>
<img src="tutorial24.solution.PNG"/>
<p>
    First we need to configure the project, open the properties window for the TDS project and set the target web project:
</p>
<img src="tutorial24.general.PNG"/>
<p>
    Next click Code Generation and then set the following properties:
</p>
<ul>
    <li>Enable Code Generation - Check</li>
    <li>Target Project</li>
    <li>Code Generation Target File - remember to add the .cs to the end of the file name</li>
    <li>Base Namespace - not that this should be the base with out the assembly name. For example if we want the final namespace to be
        GlassTds.Models just enter Models.
    </li>
</ul>
<p>
    At this time you can't set the Header Transform File or the Base Project Transform File.
</p>
<img src="tutorial24.codegenproperties.PNG"/>
<p>
    When you clicked the Enable Code Generation checkbox you should have seen an additional node appear in the TDS project:
</p>
<img src="tutorial24.tdscodegennode.PNG"/>
<p>
    Download the following three files:
</p>
<ul>
    <li>
        <a href="https://raw.github.com/mikeedwards83/tds-codegen/master/Sitecore.Master/Code%20Generation%20Templates/Helpers.tt">Helpers.tt</a>
        <a href="https://raw.github.com/mikeedwards83/tds-codegen/master/Sitecore.Master/Code%20Generation%20Templates/GlassV3Header.tt">GlassV3Header.tt</a>
        <a href="https://raw.github.com/mikeedwards83/tds-codegen/master/Sitecore.Master/Code%20Generation%20Templates/GlassV3Item.tt">GlassV3Item.tt</a>
    </li>
</ul>
<p>
    And copy and paste them beneath the Code Generation Templates node:
</p>
<img src="tutorial24.ttfiles.PNG"/>
<p>
    Now open the TDS project properties page again and configure the Header Transform File and the Base Project Transform File:
</p>
<img src="tutorial24.ttfilesconfig.PNG"/>
<p>
    We can now add some templates to our solution:
</p>
<img src="tutorial24.templateadded.PNG"/>
<p>
    TDS will automatically update and generate a new code file which will contain the generated classes.
</p>
<h2>What gets generated?</h2>
<p>
    The code generation will generate a class and an interface for each template in Sitecore. The interface generated will contain all the fields
    for the template:
</p>
<pre class="csharp">
 	/// &lt;summary&gt;
	/// ISample_Item Interface
	/// &lt;para&gt;Path: /sitecore/templates/Sample/Sample Item&lt;/para&gt;	
	/// &lt;para&gt;ID: 76036f5e-cbce-46d1-af0a-4143f9b557aa&lt;/para&gt;	
	/// &lt;/summary&gt;
	[SitecoreType(TemplateId=Sample_Item.TemplateIdString)]
	public partial interface ISample_Item : IGlassBase 
	{
		/// &lt;summary&gt;
		/// The Text field.
		/// &lt;para&gt;Field Type: Rich Text&lt;/para&gt;		
		/// &lt;para&gt;Field ID: a60acd61-a6db-4182-8329-c957982cec74&lt;/para&gt;
		/// &lt;para&gt;Custom Data: &lt;/para&gt;
		/// &lt;/summary&gt;
		[SitecoreField(Sample_Item.TextFieldName)]
		string Text  {get; set;}
			
		/// &lt;summary&gt;
		/// The Title field.
		/// &lt;para&gt;Field Type: text&lt;/para&gt;		
		/// &lt;para&gt;Field ID: 75577384-3c97-45da-a847-81b00500e250&lt;/para&gt;
		/// &lt;para&gt;Custom Data: &lt;/para&gt;
		/// &lt;/summary&gt;
		[SitecoreField(Sample_Item.TitleFieldName)]
		string Title  {get; set;}
	}
</pre>
<p>
    The class generated is the concrete version of this interface and also contains constants for field names, field IDs, template name and template Id:
</p>
<pre class="csharp">
	/// &lt;summary&gt;
	/// Sample_Item
	/// &lt;para&gt;Path: /sitecore/templates/Sample/Sample Item&lt;/para&gt;	
	/// &lt;para&gt;ID: 76036f5e-cbce-46d1-af0a-4143f9b557aa&lt;/para&gt;	
	/// &lt;/summary&gt;
	[SitecoreType(TemplateId=Sample_Item.TemplateIdString)]
	public partial class Sample_Item  : GlassBase, ISample_Item 
	{
	    
		public const string TemplateIdString = "76036f5e-cbce-46d1-af0a-4143f9b557aa";
		public static readonly ID TemplateId = new ID(TemplateIdString);
		public const string TemplateName = "Sample Item";

		/// &lt;summary&gt;
		/// The Text field.
		/// &lt;para&gt;Field Type: Rich Text&lt;/para&gt;		
		/// &lt;para&gt;Field ID: a60acd61-a6db-4182-8329-c957982cec74&lt;/para&gt;
		/// &lt;para&gt;Custom Data: &lt;/para&gt;
		/// &lt;/summary&gt;
		[global::System.CodeDom.Compiler.GeneratedCodeAttribute("Team Development for Sitecore - GlassItem.tt", "1.0")]
		[SitecoreField(Sample_Item.TextFieldName)]
		public virtual string Text  {get; set;}

		public static readonly ID TextFieldId = new ID("a60acd61-a6db-4182-8329-c957982cec74");
		public const string TextFieldName = "Text";
			
		/// &lt;summary&gt;
		/// The Title field.
		/// &lt;para&gt;Field Type: text&lt;/para&gt;		
		/// &lt;para&gt;Field ID: 75577384-3c97-45da-a847-81b00500e250&lt;/para&gt;
		/// &lt;para&gt;Custom Data: &lt;/para&gt;
		/// &lt;/summary&gt;
		[global::System.CodeDom.Compiler.GeneratedCodeAttribute("Team Development for Sitecore - GlassItem.tt", "1.0")]
		[SitecoreField(Sample_Item.TitleFieldName)]
		public virtual string Title  {get; set;}

		public static readonly ID TitleFieldId = new ID("75577384-3c97-45da-a847-81b00500e250");
		public const string TitleFieldName = "Title";
	}
</pre>
<p>
    You can then use these interfaces and class as you would any other custom built class.
</p>
<h3>The IGlassBase and GlassBase</h3>
<p>
    The IGlassBase and the GlassBase class inherited by all interfaces and classes respectively, it contains the following basic properties:
</p>
<ul>
    <li>Id - The ID for the item</li>
    <li>Language - The language for the item</li>
    <li>Version - The version of the item</li>
</ul>
<h3>Partial Classes and Interfaces</h3>
<p>
    All the classes and interfaces generated are partial, this means that you can easily extended them in a separate file without worrying about
    having your changes overwritten the next time the code gets generated. For example I might want every item to have a URL property, I can do this
    by extending the IGlassBase interface and GlassBase class:
</p>
<pre class="csharp">
	public partial interface IGlassBase{
		
        [SitecoreInfo(SitecoreInfoType.Url)]
        string Url{ get; }

	}

	public abstract partial class GlassBase : IGlassBase{
		
        [SitecoreInfo(SitecoreInfoType.Url)]
        string Url{ get; }

	}
</pre>
<h2>Property Return Types</h2>
<p>
    By default the return type of a property is determined by a switch statement that can be found in the GlassV3Item.tt file, this will work most of 
    the time but it might not return the type you want. For example you may have a MultiList field by default the code generation template will return
    this field as an enumerable of guids:
</p>
<pre class="csharp">
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Team Development for Sitecore - GlassItem.tt", "1.0")]
		[SitecoreField(Test.MultilistsFieldName)]
		public virtual IEnumerable&lt;Guid&gt; Multilists  {get; set;}
</pre>
<p>
    However you might want this to be returned as another Glass.Mapper managed type, we can do this by finding the field in the TDS content tree:
</p>
<img src="tutorial24.multilisttds.PNG"/>
<p>
    Open the properties panel for this item and enter into the Custom Data field "generic={type}" where "{type}" is the .Net type you want returned:
</p>
<img src="tutorial24.multilistcustomdata.PNG"/>
<p>
    If we manually re-generate the code the property now returns our custom type:
</p>
<pre class="csharp">
		[global::System.CodeDom.Compiler.GeneratedCodeAttribute("Team Development for Sitecore - GlassItem.tt", "1.0")]
		[SitecoreField(Test.MultilistsFieldName)]
		public virtual IEnumerable&lt;Sample_Item&gt; Multilists  {get; set;}
</pre>
<p>
    This can also be applied to properties that aren't enumerations, for example a drop link field. For properties that aren't enumerations we need to
    enter into the Custom Data field "type={type}":
</p>
<img src="tutorial24.droplinkcodedata.PNG"/>
<p>
    When the code is regenerated we see that the property returns out custom type:
</p>
<pre class="csharp">
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Team Development for Sitecore - GlassItem.tt", "1.0")]
		[SitecoreField(Test.DroplinkFieldName)]
		public virtual Sample_Item Droplink  {get; set;}
</pre>

